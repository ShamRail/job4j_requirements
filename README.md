## job4j_requirements
Проект содержит описание требований к Web проектам, выполняемых учениками проекта [Job4j.ru](https://job4j.ru/)

### Описание процесса проверки проектов

В процессе проверки Web проектов, менторы обращают внимание на:

1. [README.md](#1-readmemdreadme);
2. Структуру репозитория;
3. Структуру проекта;
4. Скрипты миграции;
5. Слой моделей данных;
6. Конфигурирование проекта;
7. Слой репозиториев;
8. Слой сервисов;
9. Слой контроллеров;
10. Оформление кода;
11. Документирование кода;
12. Тесты;
13. Оформление веб-интерфейса.

Далее описываются требования, на соответствие которым, проверяются проекты.

### [1. README.md](README)

README.md является визитной карточкой проекта. По нему формируется первое впечатление о нем, а также умениях разработчика. Отсутствие этого файла или его
неграмотное заполнение приводит к тому, что мнение портится. 

Чтобы сделать README привлекательным, нужно чтобы он соответствовал требованиям:
1. <u>Наличие README</u>. Он в принципе должен быть. Файл README.md должен располагаться в корне проекта;
2. <u>Четкая структура</u>. README.md должен иметь следующую структуру:
   1. <b>Название проекта</b>. Проекты, выполняемые в рамках курса должны иметь префикс job4j. Например, job4j_dreamjob или job4j_url_shortcut;
   2. <b>Описание проекта</b>. 3-5 предложений. Причем своими словами, а не скопированные из описания заданий курса. Это позволит
      заложить именно ваше понимание и видение проекта. Так проще будет объяснить суть проекта другому человеку. Например, на собеседение;
   3. **Стек технологий**. Это список технологий, которые были использованы при разработке. Для каждой технологии нужно указать версию 
      (например, Hibernate 5), потому что от версии к версии работа с технологиями отличается. Список обязательно должен выключать
      основной ЯП, например, Java 17, а также СУБД, например, PostgreSQL 14;
   4. **Требования к окружению**. Это список ПО, которое должно быть установлено для запуска проекта.
      Например, для большинства проектов нужны: Java 17, Maven 3.8, PostgreSQL 14;
   5. **Запуск проекта**. Эта секция README описывает шаг за шагом как запустить проект. Каждый шаг должен содержать команду, которая
      выделена в тройные кавычки `: Например, команда для создания БД: 
      ```shell
      create database cinema;
      ``` 
   6. **Взаимодействие с приложением**:
      1. Для приложений, имеющих Web интерфейс, нужно добавить скриншоты страниц. Например, страница списка задач, страница регистрации и т.п.;
      2. Для приложений, имеющих REST архитектуру, нужно описать по какому URL доступно запущенное приложение вставить таблицу с endpoint'ами и их описанием. Например,
         приложение доступно по URL `http://localhost:8080`
        <table>
         <thead>
            <tr><th>URI</th><th>Метод</th><th>Описание</th><th>Запрос</th><th>Ответ</th></tr>
         </thead>
         <tbody>
            <tr>
               <td>/site/registration</td>
               <td>POST</td>
               <td>Регистрирует сайт</td>
               <td>
      <pre>{ 
         "site": "job4j.ru" 
      }</pre>
               </td>
               <td>
               <pre>
      {
         "login": "csdzasd",
         "password: "avbcvxvxc",
         "isRegistered": true
      }
      </pre>
      </td>
            </tr>
         <tbody>
        </table>
   7. **Контакты**. Не смотря на то, что проекты являются учебными и их цель освоение технологий, считается хорошей
      практикой предоставление способа обратной связи. Можно оставить в качестве контактов почту или логин в телеграмме.
3. <u>Привлекательность README.md</u>

   Привлекательность README зависит от того применяются ли списки, изображения, таблицы, иконки, способы выделения текстов
   (заголовки, ссылки, код и т.п.) и т.д. По возможности стоит использовать их вместо простого текста. Чем нагляднее
   представлено описание, тем лучше.
   

### 2. Структура репозитория

В репозитории должен быть порядок. Для этого нужно придерживаться следующих правил:
1. <u>Отсутствие файлов локального окружения</u>. Речь о директории `.idea` и файлах `*.iml`. Желательно в самом
начале добавить их в `.gitignore`. Если работа производится в других IDE, то нужно касательно этих IDE добавлять
файлы в исключения;
2. <u>Отсутствие файлов Maven wrapper</u>. Речь о директории `.mvn` и файлах `mvnw` и `mvnw.cmd`. Тема Maven wrapper в 
курсе не освещается, поэтому эти файлы являются лишними;
3. <u>Отсутствие файлов локальных сборок</u>. Речь о директории `target`;
4. <u>Отделение файлов для README</u>. Файлы, используемые в README, должны располагаться в отдельной директории. Например, если при описании добавляются
скриншоты приложения, то они должны лежать в папке `img`;
5. <u>Оформление коммитов</u>. Если коммиты оформлены правильно, то это показывает умение работать с системой контроля версий. 
Сюда можно отнести:
   1) **Количество коммитов**. Коммитов должно быть разумное количество (> 5);
   2) **Названия коммитов**. Название коммита должно описывать, что в нем происходило. Оно должно отвечать на вопрос
   "Что сделано?" или "Что сделал?". Например, "Добавлены зависимости Log4j, Spring-Security", "Созданы скрипт инициализации БД",
   "Реализован сервис TicketService" и т.п.;
   3) **Порядок коммитов**. История коммитов должна быть наглядной, чтобы по ней можно было наблюдать, как происходила разработка проекта.
   Например, если сначала идет коммит "Реализован сервис TicketService", а потом "Реализован репозиторий TicketRepository", то становится непонятно
   как можно было реализовать сервис без репозитория для работы с БД. 

### 3. Структура проекта

Проект должен иметь четкую структуру для того чтобы в нем можно было запросто разобраться. Этот пункт имеет такие требования:
1. <u>Положение скриптов БД</u>. Это зависит от того как настроен Liquibase:
   1. **Через Maven плагин**. В таком случае скрипты должны располагаться в директории `db`, которая должна находиться в корне проекта;
   2. **Через Spring**. В таком случае скрипты должны располагаться в директории `src/main/resources/db.changelog`.
2. <u>Структура директории</u> `src/main/java`:
   1. **Корневой домен**. Корней домен должен быть `ru.job4j.<project>`, где project это название проекта, например, cinema;
   2. **Пакет `ru.job4j.<project>.model`**. Все модели данных, которые соответствуют таблицам БД, должны располагаться в этом пакете;
   3. **Пакет `ru.job4j.<project>.repository`**. Все классы-хранилища должны располагаться в этом пакете;
   4. **Пакет `ru.job4j.<project>.service`**. Все классы-сервисы должны располагаться в этом пакете;
   5. **Пакет `ru.job4j.<project>.controller`**. Все классы-контроллеры должны располагаться в этом пакете;
   6. **Пакет `ru.job4j.<project>.config`**. Все классы-конфигурации должны располагаться в этом пакете;
   7. **Иные пакеты**. Допускается создание других пакетов, например, `util`, `dto` и т.п. Пакеты должны именоваться в единственном числе.
3. <u>pom.xml</u>. Этот файл должен быть минималистичным:
   1. **Отсутствие лишних зависимостей**. Зависимости, которые не знакомы или не используются, в проекте должны отсутствовать;
   2. **Указание версии Java в одном месте**. Версию Java можно указать через maven-compiler-plugin или через properties. Нужно использовать
      только один вариант;
   3. **Версия Java**. Версия должны быть LTS, например, 8, 11 или 17, поскольку LTS версии являются стабильными. 
4. Наличие валидатора стилей кода:
   1. checkstyle.xml. Правила должна находиться в этом файле. Файл должен располагаться в корне проекта;
   2. Maven plugin. В pom.xml должен быть подключен плагин checkstyle.

### 4. Скрипты миграции

Миграция - скрипт, который вносит изменения в БД, или файл, содержащий описание, как вносить изменения в БД. 
Смысл миграций в том, чтобы автоматизировать внесение изменений в БД. 

Этот пункт включает требования как к самим скриптам, так и к вносимым изменения в схему БД:
1. Скрипты:
   1. **Формат .sql**. По курсу рассматриваются только миграции в формате sql;
   2. **Наименование скриптов**. Название должно соответствовать шаблону `00x_[dml|ddl]_описание.sql`. 
      Например, 001_ddl_create_categories_table.sql или 002_dml_insert_categories.sql;
   3. **Расположение скриптов**. Директория `db` или `src/main/resources/db.changelog`;
   4. **Выполнение скриптов**. Исключительно через Liquibase, который нужно подключить либо через Spring, либо через Maven плагин;
   5. **Декомпозиция скриптов**. Скрипты не должны быть большими. Изменения должны быть логически связанными.
      Например, создание таблицы это отдельный скрипт, ее заполнение еще один скрипт, создание другой таблицы еще один скрипт.
2. Изменения:
   1. **Комментарии**. Создаваемые таблицы нужно комментировать. Это позволит избежать проблем с толкованием, т.к. два 
      разных человека могут вкладывать разный смысл в англ. термины. Пример:
      ```postgresql
      create table categories
      (
          id serial primary key,
          name text not null unique
      );
      
      comment on table categories is 'Категории задач';
      comment on column categories.id is 'Идентификатор категории';
      comment on column categories.name is 'Название категории';
      ```
   2. **text vs varchar(n)**. Вместо `varchar(n)` используйте `varchar` или `text`. Подробнее [здесь](https://stackoverflow.com/questions/4848964/difference-between-text-and-varchar-character-varying);
   3. **Ограничения**. Ограничения должны быть как можно строже. Чаще всего придется указывать `not null` или `unique`.
      Такие ограничения позволят выявить ошибку при сохранении, а не потом.
   4. **Корректность связей**. Тут особых рекомендаций нет. Это зависит от разрабатываемого проекта;  
   5. **Название таблиц**. У таблиц должен быть единый стиль названия. Если используете множественное число `categories`,
      `users` и т.п., то придерживайтесь этих правил. Если именуете в единственном числе `category`, `user`, то именуйте все таблицы
      таким образом. 

### 5. Слой моделей данных

Модели данных описывают доменные модели предметной области, вокруг которых сосредотачивается вся наша логика. К моделям
данных предъявляются следующие требования:
1. Наименование:
   1. **Единственное число**. Например, `Category`, а не `Categories` (даже если таблица в БД `categories`);
   2. **Отсутствие префиксов и суффиксов**. Например, `Category`, а не `CategoryDto`, `DbCategory` и пр.
2. **equals() & hashcode()**. Требования к ним стандартные. Только стоит отметить, что не нужно в них помещать все
   поля;
3. **Lombok**. Применение Lombok допускается;
4. **Тип полей**. Если поле не может быть null и оно представляет примитивный тип, то нужно использовать примитивный
   тип, а не обертку. Например, `int id`, id не может быть null.

### 6. Конфигурирование проекта

Гибкость разработанного приложения достигается не только за счет соблюдения принципов SOLID, но и за счет возможности
конфигурирования без изменения кода. Этот раздел включает правила, относящиеся к файлам конфигураций:

1. Положение конфигурационных файлов:
   1. Java конфигурации. Эти файлы должны располагаться в пакете `ru.job4j.<project>.config`;
   2. Иные конфигурации. Не Java конфигурации должны располагаться в `src/main/resources`.
2. Аннотация конфигурационных файлов. Java конфигурации должны быть помечены аннотацией `@Configuration`;
3. Декомпозиция конфигураций. Настройка различных бинов должна быть декомпозирована на файлы. Речь о соблюдении
   принципа SRP. Например, DataSourceConfig, HibernateConfig, LiquibaseConfig;
4. Название конфигураций. Без сокращений. Не HbmConfig, а HibernateConfig;
5. Отсутствие хардкодинга. Приложение должно быть конфигурируемое. Все, что можно захардкодить, кроме констант, выносим
   в настройки и берем из настроек.

   Неправильный код:
   ```java
   this.rowList = IntStream.rangeClosed(1, 10).boxed().toList();
   ```
   
   Правильный код:
   ```java
   public TicketService(@Value("hall.row.count") int rowCount) {
        if (rowCount <= 0) {
            throw new IllegalArgumentException(String.format("Invalid rowCount: %d. Count must be more than 0", rowCount));
        }
        this.rowList = IntStream.rangeClosed(1, rowCount).boxed().toList();
   }
   ```

6. Принцип DRY и конфигурации. Согласно принципу DRY должен быть единственный источник правды. Упрощенно, у вас должен
   быть один конфигурационный файл, например, для подключения к БД. Если в проекте их несколько, то непонятно какой из них корректный.

### 7. Слой репозиториев

Репозиторий - это [шаблон проектирования](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design#the-repository-pattern) (не GoF), который предлагает абстракции по работе с данными доменных моделей.
Работа с данными предполагает CRUD (Create, Read, Update, Delete) операции. Большинство проектов Job4j используют
этот шаблон. При использовании этого шаблона нужно соблюдать следующие правила:

1. Положение репозиториев. Класс-репозитории должны располагаться в пакете `ru.job4j.<project>.repository`;
2. Названия классов. Префикс берется от пакета, например, `UserRepository`, а не `UserDbStore`;
   1. Соблюдение SOLID. Особенно стоит учитывать принципы ниже:
      1. SRP. Класс репозиторий должен работать со своей доменной моделью. Например, `MovieRepository` не должен заниматься
         хранением `Session` модели;
      2. OCP. Класс репозиторий должен реализовывать интерфейс. Например, `PostgresUserRepository` должен реализовывать `UserRepository`;
      3. DIP. Класс репозиторий должен зависеть от абстракций, а не реализаций.

         Неправильный код:
         ```java
         private final BasicDataSource dataSource;
   
         public TicketRepository(BasicDataSource dataSource) {
              this.dataSource = dataSource;
         }
         ```

         Правильный код:
         ```java
         private final DataSource dataSource;
   
         public TicketRepository(DataSource dataSource) {
              this.dataSource = dataSource;
         }
         ```
3. Название методов. Названия методов должны соответствовать [спецификации Spring JPA](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#appendix.query.method.subject).
   Не все проекты Job4j работают с Spring JPA, тем не менее, эта спецификация описывает наиболее часто используемые 
   слова, которые позволяют с легкостью понять, что метод делает, без необходимости заглядывать в реализацию.

### 8. Слой сервисов

Сервисы это ради чего пишется приложение. При разработке классов-сервис стоит уделить внимание на:
1. Расположение сервисов. Сервисы должны располагаться в пакете `ru.job4j.<project>.service`;
2. Наименование сервисов. У сервисов должен быть суффикс `Service`, например, `PostService`;
3. Соблюдение SOLID. Особенно стоит отметить:
   1. Реализация интерфейсов. Сервисы должны реализовывать интерфейсы. Например, например, `SimplePostService` должен реализовывать `PostService`;
   2. Зависимость от абстракций. Сервисы должны зависеть от интерфейсов, а не конкретных реализаций.
4. Концентрация логики. Сервисы должны быть универсальны вне зависимости от того какие контроллеры в приложении.
   Частой ошибкой здесь является перенос логики в слой контроллеров. Например, валидация данных. 

### 9. Слой контроллеров и представлений

Контроллеры это связующее звено между вашим приложением и реальным миром. К контроллерам предъявляются следующие требования:
1. Расположение контроллеров. Контроллеры должны располагаться в пакете `ru.job4j.<project>.controller`;
2. Наименование контроллеров. У контроллеров должен быть суффикс `Controller`, например, `PostController`, а не `PostControl`;
3. Обработка ошибок. Если при обработке происходит ошибка, то контроллер должен сообщать об этом пользователю. Но выброс
   исключений должен быть на уровне сервисов! 
   
   Неправильный код:

   ```java
   // сервис
   public Task save(Task task) {
        return taskRepository.save(task);
   }
   // ...
   // контроллер
   public ModelAndView saveTask(@ModelAttribute("task") Task task) {
        Optional<User> userOptional = userService.findById(task.getUserId());
        if (userOptional.isEmpty()) {
            return new ModelAndView("error/404", "errorMessage", new ExceptionMessage("User with this id is not found"));
        }
        String title = task.getTitle();
        if (title == null) {
            return new ModelAndView("error/400", "errorMessage", new ExceptionMessage("Task title must not be empty"));
        }
        taskService.save(task);
        return new ModelAndView("task/list");
   }
   ```
   
   Этот код нарушает SRP в классе TaskController, потому что этот класс занимается и валидацией и обработкой веб-запросов.
   К тому же при смене контроллера, например, на контроллер очереди сообщений класс TaskService становится непригодным, потому что
   он не содержит логику, которую должен содержать. 

   Правильный код:

      ```java
   // сервис
   public Task save(Task task) {
        Optional<User> userOptional = userService.findById(task.getUserId());
        if (userOptional.isEmpty()) {
            throw new NoSuchElementException("User with this id is not found");
        }
        String title = task.getTitle();
        if (title == null) {
            throw new IllegalArgumentException("Task title must not be empty");
        }
        return taskRepository.save(task);
   }
   // ...
   // контроллер
   public ModelAndView saveTask(@ModelAttribute("task") Task task) {
        try {
            taskService.save(task);
            return new ModelAndView("task/list");
        } catch(NoSuchElementException exception) {
            return new ModelAndView("error/404", "errorMessage", new ExceptionMessage(exception.getMessage()));
        } catch(IllegalArgumentException exception) {
            return new ModelAndView("error/400", "errorMessage", new ExceptionMessage(exception.getMessage()));
        }
   }
   ```

   **Важно**. Если вам уже знакомы темы `@ExceptionHandler` или `@ControllerAdvise`, то можете использовать их.


4. Представления (View):
   1. Группировка представлений. Группируйте представления по директориям в зависимости от доменной модели. Например, для Task
      можно создать представления в директории `templates/task` `task/list`, `task/creationForm` и т.д.
   2. Представления вывода ошибок. Представления, который отвечают за вывод ошибок, должны быть директории `templates/error`;
   3. Вывод ошибок. Представление должно содержать текст ошибки и ссылку на какую либо страниц. Например,
      если пользователь допустил ошибку при создании задачи, то можно выводить ссылку, ведущую на форму создания
      задачи, т.к. после полученного сообщения должен уже успешно ее создать. 

### 10. Оформление кода

Хорошо написанный и оформленный код дорогого стоит. Под требованиями к оформлению имеется в виду:
1. Соблюдение Checkstyle. Правила должны лежать в корне проекта в файле `checkstyle.xml`, а валидация должна выполняться Maven плагином;
2. Соблюдение [Java Code Convention](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html).
   Часть этих правил проверяет Checkstyle, но он не может проверить семантику. Частые ошибки:
   1. Название методов. Например, `cells()`. Если ознакомиться с файлом по ссылке, то можно прочитать `Methods should be verbs`.
      Следовательно, такое название это нарушение. Этот метод можно назвать `getCellNumbers()`;
   2. Название классов. Число должно быть единственное, т.е. не `Customers`, а `Customer`;
   3. Название переменных. Например, `numberOfHallCells`. Желательно, чтобы переменная не состояла более чем из 2 слов. В данном случае
      можно назвать `cellNumbers`.
3. Общие правила именования (доп. [здесь](https://stackoverflow.com/questions/2814805/java-interfaces-implementation-naming-convention)):
   1. Суффикс от названия пакета. В проектах используется функциональная декомпозиция по пакетам. Сервисы в один пакет, контроллеры 
      в другой пакет и т.д. Суффикс должен говорить о принадлежности пакету и функциональном назначении. Например, `Task`,
      `TaskRepository`, `TaskService`, `TaskController`.  Сразу должно быть понятно, где они должны лежать и в чем их назначение.
   2. Суффикс от названия интерфейса. Например, по названию `SimpleTaskService` должно быть понятно, что это реализация `TaskService`.
      Аналогично, `ArrayList` от `List`

### 11. Документирование кода

Даже хорошо написанный код не всегда просто сразу понять, поэтому код нужно документировать. Что самое важное, документирование
показывает, что вы понимаете зачем оно нужно и умеете его производить. Документировать = писать JavaDoc. Документировать нужно:

1. Классы (все). Примеры ниже:
   ```java
   /**
   * Модель данных задачи
   */
   public class Task {}
   ```
   
   ```java
   /**
   * Хранилище для работы с данными задач
   * @see ru.job4j.todo.model.Task
   */
   public interface TaskRepository {}
   ```
   и т.п.
2. Поля (доменных моделей). Пример:
      ```java
   /**
   * Модель данных задачи
   */
   public class Task {
        /**
        * Идентификатор задачи
        */
        private int id;
   
        /**
        * Название задачи
        */
        private String name;
   }
   ```
3. Методы (все кроме get/set). Пример:

   ```java
   /**
   * Хранилище для работы с данными задач
   * @see ru.job4j.todo.model.User
   */
   public interface UserRepository {
    
        /**
        * Выполняет сохранение пользователя. При успешном сохранении возвращает Optional с 
        * объектом пользователя, у которого проинициализировано id. Иначе возвращает Optional.empty()
        * Сохранении может не произойти, если сохраняется пользователь у которого логин совпадает с логином другого пользователя.
        *
        * @param user сохраняемый пользователь
        * @return Optional.of(user) при успешном сохранении, иначе Optional.empty()
        */
        Optiona<User> save(User user);
        
        /**
        * Возвращает список всех пользователей
        *
        * @return список всех пользователей
        */
        List<Task> findAll();
    
   }
   ```

4. Аннотации потокобезопасности. Если используете аннотацию `@ThreadSafe`, то обязательно опишите в JavaDoc. Укажите, что 
   является непотокобезопасным и за счет чего она достигается. Подробнее можно об этом почитать в книге Д. Блоха, в главе 11.5
   "Документируйте безопасность с точки зрения потоков"

### 12. Тесты

К моменту написания веб-проектов вам должно быть знакомо тестирование. Тестовые веб-проекты должны выдерживать требования:
1. Интеграционные тесты слоя хранения данных. Для этого классы-хранилища должны работать в тестовом окружении с базой,
   хранимой либо в файловой системе либо в памяти;
2. Модульные тесты слоя сервисов. Тесты должны проверять логику сервисов. Вместо зависимостей нужно использовать моки;
3. Наименование тестов. Названия тестовых методов должны соответствовать шаблону when*Then, например, `whenSaveTaskThenGetTheSameFromDatabase()`;
4. Документирование тестов. Тестовые методы должны содержать JavaDoc, описывающий какой сценарий проверяет тест;
5. Наличие плагина JaCoCo. Как минимум, 50% кода должны быть покрыто тестами. % покрытия можно узнать из сгенерированного отчета JaCoCo.
   В нем же можно увидеть, как часть код не покрыта тестами.

### 13. Оформление веб-интерфейса
